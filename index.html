<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Analizador de Funciones.">
    <meta name="keywords" content="analizador de funciones, graficador, matemáticas, cálculo, funciones, online">
    <meta name="author" content="David Chungata">

    <title>Analizador de Funciones</title>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.0/math.min.js"></script>

    <style>
        :root {
            /* Paleta de colores más moderna y limpia */
            --primary-blue: #30353d; /* Azul oscuro elegante */
            --primary-light-blue: #3B82F6; /* Azul brillante y moderno para la gráfica */
            --secondary-blue: #DBEAFE; /* Azul claro para fondos secundarios */
            --gray-bg: #F3F4F6; /* Fondo general de la página */
            --white-card: #FFFFFF; /* Fondo para tarjetas y secciones */
            --border-color: #E5E7EB; /* Bordes suaves */
            --text-dark: #1F2937; /* Texto principal oscuro */
            --text-medium: #4B5563; /* Texto secundario */
            --text-light: #6B7280; /* Texto de ayuda/placeholder */
            --info-bubble: #1F2937; /* Fondo oscuro para tooltips */
            --success-bg: #D1FAE5; /* Fondo verde para resultados positivos */
            --success-text: #065F46; /* Texto verde para resultados positivos */
            --error-bg: #FEE2E2; /* Fondo rojo para errores */
            --error-text: #991B1B; /* Texto rojo para errores */
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--gray-bg);
            color: var(--text-dark);
            display: flex;
            justify-content: center;
            min-height: 100vh;
            box-sizing: border-box;
            overflow-x: hidden;
            padding: 30px 15px; /* Espaciado general */
        }

        .app-container {
            width: 100%;
            max-width: 800px; /* Ancho máximo para la aplicación */
            display: flex;
            flex-direction: column;
            gap: 25px; /* Espacio entre secciones */
        }

        .app-title {
            text-align: center;
            color: var(--primary-blue);
            font-size: 2.8em;
            margin-bottom: 25px;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        /* Estilo general para las tarjetas/secciones */
        section {
            background-color: var(--white-card);
            border-radius: 12px; /* Más redondeado */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08); /* Sombra más pronunciada pero suave */
            padding: 30px;
            border: 1px solid var(--border-color); /* Borde sutil */
        }

        /* SECCIÓN DE INSTRUCCIONES / AYUDA SIMPLIFICADA */
        .info-card {
            background-color: var(--secondary-blue);
            border: 1px solid var(--primary-light-blue);
            color: var(--text-medium);
            padding: 20px 25px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .info-header {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 15px;
        }

        .info-icon {
            color: var(--primary-blue);
            font-size: 1.6em;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .info-card p {
            margin: 0;
            line-height: 1.6;
        }

        .example-text {
            font-weight: 600;
            color: var(--text-dark);
            margin-top: 15px;
            border-top: 1px dashed var(--border-color);
            padding-top: 15px;
        }

        /* SECCIÓN DE ENTRADA Y CONFIGURACIÓN DE LA FUNCIÓN */
        .input-section {
            display: grid;
            grid-template-columns: 1fr; /* Una columna por defecto */
            gap: 20px; /* Espacio entre filas */
        }

        @media (min-width: 600px) {
            .input-section {
                grid-template-columns: repeat(2, 1fr); /* Dos columnas en pantallas más grandes */
            }
            .input-section .action-button {
                grid-column: span 2; /* El botón ocupa ambas columnas */
            }
        }

        .form-group {
            display: flex;
            flex-direction: column;
            position: relative; /* Para el tooltip */
        }

        .form-label {
            font-weight: 500;
            margin-bottom: 10px;
            color: var(--text-medium);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95em;
        }

        .form-input {
            padding: 14px 18px;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            font-size: 1em;
            color: var(--text-dark);
            outline: none;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            background-color: var(--gray-bg); /* Fondo sutil para inputs */
        }

        .form-input:focus {
            border-color: var(--primary-light-blue);
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.2); /* Sombra de foco */
            background-color: var(--white-card);
        }

        /* Tooltip */
        .tooltip-trigger {
            position: relative;
            cursor: help;
            color: var(--primary-light-blue);
            display: inline-flex; /* Para que el icono se alinee con el texto */
            align-items: center;
        }

        .tooltip-trigger .fas {
            font-size: 0.9em;
        }

        .tooltip-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background-color: var(--info-bubble);
            color: white;
            padding: 12px 18px;
            border-radius: 8px;
            font-size: 0.8em;
            width: 280px;
            z-index: 10;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.25);
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform: translateY(10px);
            white-space: normal;
            line-height: 1.5;
        }

        .tooltip-trigger:hover .tooltip-content,
        .tooltip-trigger:focus-within .tooltip-content {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .tooltip-content p {
            margin: 5px 0;
        }
        .tooltip-content p:first-child { margin-top: 0; }
        .tooltip-content p:last-child { margin-bottom: 0; }

        /* Botones */
        .action-button {
            background-color: var(--primary-blue);
            color: white;
            padding: 15px 25px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 0 6px 15px rgba(59, 130, 246, 0.3);
        }

        .action-button:hover {
            background-color: #2563EB; /* Azul más oscuro */
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.4);
        }

        .action-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(59, 130, 246, 0.2);
        }

        .button-icon {
            font-size: 1.2em;
        }

        /* SECCIÓN DE GRÁFICO Y RESULTADOS */
        .results-section {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .graph-container {
            min-height: 400px; /* Altura mínima para la gráfica */
            background-color: var(--white-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            overflow: hidden; /* Asegura que la gráfica no se salga */
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative; /* Necesario para que Plotly se posicione correctamente */
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.08);
        }

        /* Asegurarse de que el contenido de Plotly ocupe todo el espacio */
        .js-plotly-plot {
            width: 100% !important;
            height: 100% !important;
        }

        .analysis-output {
            background-color: var(--gray-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 20px;
        }

        .analysis-output h3 {
            color: var(--primary-blue);
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.2em;
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .analysis-output pre {
            white-space: pre-wrap;
            word-break: break-word;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.95em;
            color: var(--text-dark);
            margin: 0;
            min-height: 60px; /* Espacio mínimo para el texto */
            line-height: 1.5;
        }
        
        .analysis-output p {
            margin: 5px 0;
        }

        /* Estilos para mensajes de éxito/error */
        .message-box {
            padding: 12px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 0.95em;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }
        .message-box.error {
            background-color: var(--error-bg);
            color: var(--error-text);
            border: 1px solid var(--error-text);
        }
        .message-box.info {
            background-color: var(--secondary-blue);
            color: var(--text-medium);
            border: 1px solid var(--primary-light-blue);
        }
        .message-box.success {
            background-color: var(--success-bg);
            color: var(--success-text);
            border: 1px solid var(--success-text);
        }
        .message-box i {
            margin-top: 2px;
            font-size: 1.2em;
        }

        /* Estilo para explicaciones dentro del pre */
        .explanation {
            font-size: 0.85em;
            color: var(--text-medium);
            background-color: var(--gray-bg);
            padding: 8px 12px;
            border-radius: 6px;
            margin-top: 10px;
            margin-bottom: 10px;
            border-left: 3px solid var(--primary-light-blue);
        }

        /* Ajustes para pantallas pequeñas */
        @media (max-width: 480px) {
            .app-title {
                font-size: 2.2em;
            }
            section {
                padding: 20px;
            }
            .form-input, .action-button {
                padding: 12px 15px;
                font-size: 1em;
            }
            .info-card {
                padding: 15px;
            }
            .tooltip-content {
                width: 200px;
                font-size: 0.75em;
                padding: 10px;
            }
        }
    </style>
</head>
<body>

    <div class="app-container">

        <h1 class="app-title">Analizador de Funciones</h1>

        <section class="info-card">
            <div class="info-header">
                <i class="fas fa-info-circle info-icon"></i>
                <p>Ingresa una función en el campo de abajo. Puedes usar `x`, `sin(x)`, `cos(x)`, `tan(x)`, `log(x)`, `abs(x)`, `sqrt(x)`, `pi`, `e`, potencias (`x^2`), y paréntesis `( )`.</p>
            </div>
            <p class="example-text">**Ejemplos:** `x^2`, `sin(x)`, `2*x + 3`, `(x+1)/(x-1)`</p>
        </section>

        <section class="input-section">
            <div class="form-group">
                <label for="function-input" class="form-label">Función:</label>
                <input type="text" id="function-input" class="form-input" value="x^2" placeholder="Ej: x^2 + 2*x - 1">
            </div>

            <div class="form-group">
                <label for="order-input" class="form-label">
                    Análisis Adicional (opcional): 
                    <span class="tooltip-trigger">
                        <i class="fas fa-question-circle"></i>
                        <span class="tooltip-content">
                            <p>"dominio": Describe el dominio.</p>
                            <p>"rango": Describe el rango.</p>
                            <p>"asíntotas": Describe las asíntotas.</p>
                            <p>"monotonía": Indica si es creciente/decreciente.</p>
                            <p>"simetría": Indica si es par/impar.</p>
                            <p>"tabla N": Genera una tabla con N puntos. (Ej: "tabla 10")</p>
                        </span>
                    </span>
                </label>
                <input type="text" id="order-input" class="form-input" placeholder="Ej: dominio">
            </div>

            <div class="form-group">
                <label for="interval-x-input" class="form-label">Intervalo X (ej. -5,5)</label>
                <input type="text" id="interval-x-input" class="form-input" value="-5,5" placeholder="Ej: -10,10">
            </div>

            <button id="analyze-button" class="action-button primary-button">
                <i class="fas fa-chart-line button-icon"></i> Analizar y Graficar
            </button>
        </section>

        <section class="results-section">
            <div class="graph-container" id="graph-container">
                </div>
            
            <div class="analysis-output">
                <h3>Resultados del Análisis:</h3>
                <pre id="analysis-text">Introduce una función y haz clic en "Analizar y Graficar".</pre>
            </div>
        </section>

    </div> 

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Referencias a los elementos del DOM
            const functionInput = document.getElementById('function-input');
            const orderInput = document.getElementById('order-input');
            const intervalXInput = document.getElementById('interval-x-input');
            const analyzeButton = document.getElementById('analyze-button');
            const graphContainer = document.getElementById('graph-container'); // Contenedor para Plotly
            const analysisText = document.getElementById('analysis-text');

            // Función para parsear función a trozos (si aplica)
            function parseFuncionATrozos(str) {
                const partes = str.split(";").map(p => p.trim()).filter(p => p.length > 0);

                if (partes.length === 1 && !partes[0].includes(':')) {
                    try {
                        const node = math.parse(str);
                        return x => {
                            try {
                                return node.evaluate({ x: x });
                            } catch (e) {
                                return NaN; // Error de evaluación (ej. log de negativo)
                            }
                        };
                    } catch (e) {
                        throw new Error("La expresión de la función no es válida.");
                    }
                }

                const condiciones = partes.map(p => {
                    let [cond, expr] = p.split(":");
                    if (!expr || !cond) {
                        throw new Error("Formato de función a trozos inválido. Usa 'condicion : expresion;'.");
                    }
                    return {
                        condNode: math.parse(cond.trim()),
                        exprNode: math.parse(expr.trim())
                    };
                });

                return x => {
                    for (let c of condiciones) {
                        try {
                            if (c.condNode.evaluate({ x })) {
                                return c.exprNode.evaluate({ x });
                            }
                        } catch (e) {
                            return NaN;
                        }
                    }
                    return NaN;
                };
            }

            // Función para obtener el tipo de función
            function getTipoFuncion(funcStr) {
                funcStr = funcStr.toLowerCase();
                if (funcStr.includes('/') && funcStr.match(/\/.*\bx\b/)) {
                    return "racional";
                }
                if (!funcStr.includes('/') && !funcStr.includes('sqrt') && !funcStr.includes('log') &&
                    !funcStr.includes('sin') && !funcStr.includes('cos') && !funcStr.includes('tan') &&
                    !funcStr.includes('exp') && !funcStr.includes('abs') && !funcStr.includes('pi') && !funcStr.includes('e')) {
                    try {
                        const node = math.parse(funcStr);
                        let isPolynomial = true;
                        node.filter(n => n.isSymbolNode || n.isFunctionNode || n.isOperatorNode || n.isParenthesisNode).forEach(n => {
                            if (n.isFunctionNode) { isPolynomial = false; } 
                            else if (n.isSymbolNode && n.name !== 'x') { isPolynomial = false; } 
                            else if (n.isOperatorNode && n.op === '^') {
                                const powerNode = n.args[1];
                                if (powerNode && powerNode.isConstantNode && (powerNode.value < 0 || !Number.isInteger(powerNode.value))) {
                                    isPolynomial = false;
                                }
                            }
                        });
                        return isPolynomial ? "polinomica" : "otra";
                    } catch (e) {
                        return "otra";
                    }
                }
                if (funcStr.includes('sqrt(')) {
                    return "raiz_cuadrada";
                }
                if (funcStr.includes(':') && funcStr.includes(';')) {
                    return "a_trozos";
                }
                return "otra";
            }

            // Función principal para analizar y graficar
            async function analyzeAndPlot() {
                const functionExpression = functionInput.value.trim();
                const order = orderInput.value.trim().toLowerCase();
                const intervalXStr = intervalXInput.value.trim();

                analysisText.innerHTML = '<div class="message-box info"><i class="fas fa-sync fa-spin"></i> Calculando...</div>';
                graphContainer.innerHTML = ''; // Limpiar gráfico anterior

                if (!functionExpression) {
                    analysisText.innerHTML = '<div class="message-box error"><i class="fas fa-exclamation-triangle"></i> Por favor, introduce una función.</div>';
                    return;
                }

                let startX = -10, endX = 10;
                const intervalParts = intervalXStr.split(',').map(val => parseFloat(val.trim()));
                if (intervalParts.length === 2 && !isNaN(intervalParts[0]) && !isNaN(intervalParts[1])) {
                    startX = intervalParts[0];
                    endX = intervalParts[1];
                    if (startX >= endX) {
                        analysisText.innerHTML = '<div class="message-box error"><i class="fas fa-exclamation-triangle"></i> Intervalo X inválido. El inicio debe ser menor que el fin (ej. -10,10).</div>';
                        return;
                    }
                } else {
                    analysisText.innerHTML = '<div class="message-box error"><i class="fas fa-exclamation-triangle"></i> Formato de intervalo X inválido. Usa "inicio,fin" (ej. -10,10).</div>';
                    return;
                }

                let f;
                try {
                    f = parseFuncionATrozos(functionExpression);
                } catch (e) {
                    analysisText.innerHTML = `<div class="message-box error"><i class="fas fa-exclamation-triangle"></i> Error al parsear la función: ${e.message}</div>`;
                    return;
                }

                // Generar puntos para la gráfica
                const numPoints = 500; // Suficientes puntos para una gráfica suave
                const xs = [];
                const ys = [];
                let minYGraph = Infinity, maxYGraph = -Infinity;

                for (let i = 0; i <= numPoints; i++) {
                    const x = startX + ((endX - startX) * i) / numPoints;
                    let y = f(x);

                    // Reemplazar Infinity/-Infinity con NaN para Plotly
                    if (!isFinite(y)) y = NaN; 
                    
                    xs.push(x);
                    ys.push(y);

                    if (isFinite(y)) {
                        minYGraph = Math.min(minYGraph, y);
                        maxYGraph = Math.max(maxYGraph, y);
                    }
                }

                // Configurar el layout de Plotly
                const plotLayout = {
                    margin: { t: 30, b: 50, l: 60, r: 20 },
                    xaxis: {
                        title: { text: "x", font: { family: 'Inter', size: 16, color: getComputedStyle(document.documentElement).getPropertyValue('--text-dark') } },
                        range: [startX, endX], // Usar el rango X del usuario
                        gridcolor: getComputedStyle(document.documentElement).getPropertyValue('--border-color'),
                        zerolinecolor: '#888',
                        zerolinewidth: 2,
                        showline: true,
                        linecolor: '#888',
                        showarrow: true, // Mostrar flecha en el extremo del eje
                        arrowhead: 2,     // Tipo de flecha
                        arrowsize: 1,     // Tamaño de la flecha
                        rangemode: 'normal' // Permite que el rango se ajuste a los datos (flexible)
                    },
                    yaxis: {
                        title: { text: "f(x)", font: { family: 'Inter', size: 16, color: getComputedStyle(document.documentElement).getPropertyValue('--text-dark') } },
                        // Rango Y dinámico para que no se vea cortado, pero no se "aleje" demasiado
                        range: [minYGraph === Infinity ? -10 : minYGraph - (Math.abs(minYGraph) * 0.1 || 1), 
                                maxYGraph === -Infinity ? 10 : maxYGraph + (Math.abs(maxYGraph) * 0.1 || 1)],
                        gridcolor: getComputedStyle(document.documentElement).getPropertyValue('--border-color'),
                        zerolinecolor: '#888',
                        zerolinewidth: 2,
                        showline: true,
                        linecolor: '#888',
                        showarrow: true,
                        arrowhead: 2,
                        arrowsize: 1,
                        rangemode: 'normal' // O 'tozero' si siempre quieres incluir el 0, pero 'normal' es más flexible.
                    },
                    plot_bgcolor: getComputedStyle(document.documentElement).getPropertyValue('--white-card'),
                    paper_bgcolor: getComputedStyle(document.documentElement).getPropertyValue('--white-card'),
                    font: {
                        family: 'Inter',
                        color: getComputedStyle(document.documentElement).getPropertyValue('--text-dark')
                    },
                    hovermode: 'closest' // Mejorar el hover
                };

                // Datos de la traza para Plotly
                const trace = {
                    x: xs,
                    y: ys,
                    mode: 'lines',
                    type: 'scatter',
                    name: 'f(x)',
                    line: { color: getComputedStyle(document.documentElement).getPropertyValue('--primary-light-blue'), width: 3 },
                    hoverinfo: 'x+y'
                };

                try {
                    Plotly.newPlot('graph-container', [trace], plotLayout, { 
                        responsive: true, // Hacer el gráfico responsivo
                        displayModeBar: false // Ocultar la barra de herramientas de Plotly
                    });
                } catch (error) {
                    analysisText.innerHTML = `<div class="message-box error"><i class="fas fa-exclamation-triangle"></i> Error al graficar: ${error.message}</div>`;
                    console.error("Error al graficar con Plotly:", error);
                    return;
                }

                // --- Lógica de Análisis Adicional ---
                let analysisOutputHTML = `<h3>Resultados del Análisis:</h3>`;
                analysisOutputHTML += `<div class="message-box success"><i class="fas fa-check-circle"></i> Función "${functionExpression}" graficada con éxito en [${startX}, ${endX}].</div>`;
                analysisOutputHTML += `<p><b>Tipo de función:</b> ${getTipoFuncion(functionExpression).replace('_', ' ')}</p>`;

                const tipoFuncion = getTipoFuncion(functionExpression);

                if (order.includes("dominio") || order === "") {
                    analysisOutputHTML += `<p><b>Dominio:</b></p>`;
                    switch (tipoFuncion) {
                        case "racional":
                            analysisOutputHTML += `<div class="explanation">Para una **función racional** ($f(x) = P(x)/Q(x)$), el dominio incluye todos los números reales excepto aquellos valores de $x$ que hacen que el **denominador ($Q(x)$) sea cero**. Debes igualar el denominador a cero para encontrar las restricciones.</div>`;
                            break;
                        case "polinomica":
                            analysisOutputHTML += `<div class="explanation">El dominio de cualquier **función polinómica** son **todos los números reales** $(-\\infty, \\infty)$, ya que no hay valores de $x$ que causen indefiniciones (como divisiones por cero o raíces de números negativos).</div>`;
                            break;
                        case "raiz_cuadrada":
                            analysisOutputHTML += `<div class="explanation">Para una **función raíz cuadrada** ($f(x) = \\sqrt{g(x)}$), el dominio está definido por la condición de que la expresión bajo la raíz (el radicando $g(x)$) no puede ser negativa. Por lo tanto, debes establecer $g(x) \\ge 0$ y resolver la desigualdad.</div>`;
                            break;
                        case "a_trozos":
                            analysisOutputHTML += `<div class="explanation">Para una **función a trozos**, el dominio se define por las **condiciones especificadas para cada trozo**. La unión de los intervalos donde cada trozo está definido forma el dominio total de la función.</div>`;
                            break;
                        default:
                            analysisOutputHTML += `<div class="explanation">El dominio de una función son todos los valores de $x$ para los cuales la función está definida. Generalmente, buscamos evitar divisiones por cero, raíces pares de números negativos o argumentos no válidos en logaritmos.</div>`;
                    }
                    const validXsForDomain = xs.filter((val, index) => isFinite(ys[index]));
                    if (validXsForDomain.length > 0) {
                        const firstValidX = validXsForDomain[0];
                        const lastValidX = validXsForDomain[validXsForDomain.length - 1];
                        analysisOutputHTML += `<p><b>Dominio aproximado en el intervalo [${startX}, ${endX}]:</b> $[${firstValidX.toFixed(3)}, ${lastValidX.toFixed(3)}]$</p>`;
                    } else {
                        analysisOutputHTML += `<p>La función no está definida en el intervalo de $x$ dado.</p>`;
                    }
                }

                if (order.includes("rango") || order === "") {
                    analysisOutputHTML += `<p><b>Rango:</b></p>`;
                    const validYs = ys.filter(y => !isNaN(y) && isFinite(y));
                    if (validYs.length > 0) {
                        const minY = Math.min(...validYs);
                        const maxY = Math.max(...validYs);
                        analysisOutputHTML += `<p><b>Rango aproximado en el intervalo [${startX}, ${endX}]:</b> $[${minY.toFixed(3)}, ${maxY.toFixed(3)}]$</p>`;
                    } else {
                        analysisOutputHTML += `<p>No se pudo determinar el rango en el intervalo.</p>`;
                    }
                    switch (tipoFuncion) {
                        case "racional":
                            analysisOutputHTML += `<div class="explanation">El rango de una **función racional** puede ser más complejo y a menudo implica analizar las asíntotas horizontales o el comportamiento de la función cuando $x$ se acerca a infinito. El rango generalmente excluye el valor de la asíntota horizontal (si existe).</div>`;
                            break;
                        case "polinomica":
                            const degreeMatch = functionExpression.match(/x\^(\d+)/);
                            let degree = 0;
                            if (degreeMatch) { degree = parseInt(degreeMatch[1]); } else if (functionExpression.includes('x')) { degree = 1; }
                            if (degree % 2 !== 0 && degree !== 0) {
                                analysisOutputHTML += `<div class="explanation">Si el grado de una **función polinómica** es **impar**, su rango son **todos los números reales** $(-\\infty, \\infty)$.</div>`;
                            } else if (degree % 2 === 0 && degree !== 0) {
                                analysisOutputHTML += `<div class="explanation">Si el grado de una **función polinómica** es **par**, su rango tiene un límite inferior o superior, dependiendo si la gráfica se abre hacia arriba o hacia abajo. El rango dependerá del valor 'y' del vértice (punto máximo o mínimo).</div>`;
                            } else {
                                 analysisOutputHTML += `<div class="explanation">El rango de una **función polinómica** de grado par tiene un límite superior o inferior. Para grados impares, el rango son todos los números reales.</div>`;
                            }
                            break;
                        case "raiz_cuadrada":
                            analysisOutputHTML += `<div class="explanation">El rango de una **función raíz cuadrada** básica ($\\sqrt{x}$) es $[0, \\infty)$, ya que la raíz cuadrada principal siempre devuelve un valor no negativo. Las transformaciones pueden cambiar este rango.</div>`;
                            break;
                        case "a_trozos":
                            analysisOutputHTML += `<div class="explanation">Para una **función a trozos**, el rango es la **unión de los rangos** de cada trozo de la función sobre sus respectivos dominios.</div>`;
                            break;
                        default:
                            analysisOutputHTML += `<div class="explanation">El rango de una función son todos los valores que $f(x)$ puede tomar (es decir, los valores de $y$). Se determina observando los valores que la función alcanza en el eje $y$.</div>`;
                    }
                }

                if (order.includes("asíntotas") || order === "") {
                    analysisOutputHTML += `<p><b>Asíntotas:</b></p>`;
                    const asintotasV = new Set();
                    const tol = 0.05; // Tolerancia para la detección de asintotas
                    const stepSize = (endX - startX) / numPoints;

                    for (let i = 1; i < ys.length; i++) {
                        const xPrev = xs[i - 1];
                        const yPrev = ys[i - 1];
                        const xCurr = xs[i];
                        const yCurr = ys[i];

                        // Detección de asíntotas verticales por cambio de signo en y o salto abrupto
                        if ((yPrev < -1e5 && yCurr > 1e5) || (yPrev > 1e5 && yCurr < -1e5) ||
                            (isNaN(yPrev) && isFinite(yCurr)) || (isFinite(yPrev) && isNaN(yCurr)) ||
                            (isFinite(yPrev) && isFinite(yCurr) && Math.abs(yCurr - yPrev) > 1000 * stepSize)
                        ) {
                            asintotasV.add(((xPrev + xCurr) / 2).toFixed(3));
                        }
                    }

                    if (asintotasV.size > 0) {
                        analysisOutputHTML += `<p><b>Asíntotas verticales aproximadas en $x \\approx$</b> ${Array.from(asintotasV).join(", ")}</p>`;
                    } else {
                        analysisOutputHTML += "<p>No se detectaron asíntotas verticales significativas en el intervalo.</p>";
                    }

                    // Detección de asíntotas horizontales
                    const validYsAtEnds = ys.filter(y => !isNaN(y) && isFinite(y));
                    let ahDetectada = false;

                    if (validYsAtEnds.length > 0 && (endX - startX) > 50) { // Solo si el intervalo es amplio
                        const firstValidY = validYs[0];
                        const lastValidY = validYs[validYs.length - 1];

                        if (Math.abs(firstValidY - lastValidY) < tol && Math.abs(firstValidY) < Math.max(Math.abs(minYGraph), Math.abs(maxYGraph)) * 0.1) {
                            analysisOutputHTML += `<p><b>Asíntota horizontal aproximada:</b> $y = ${lastValidY.toFixed(3)}$</p>`;
                            ahDetectada = true;
                        }
                    }
                    if (!ahDetectada) {
                        analysisOutputHTML += "<p>No se detectó asíntota horizontal clara en el intervalo.</p>";
                    }
                    analysisOutputHTML += `<div class="explanation">Una **asíntota vertical** ($x = c$) ocurre donde la función tiende a infinito (o menos infinito). Una **asíntota horizontal** ($y = L$) es una línea a la que la función se aproxima cuando $x$ tiende a $\\pm\\infty$.</div>`;
                }

                if (order.includes("tabla")) {
                    let n = 5;
                    const m = order.match(/\d+/);
                    if (m) n = parseInt(m[0]);
                    if (n < 2 || n > 100) {
                        analysisOutputHTML += `<div class="message-box error"><i class="fas fa-exclamation-triangle"></i> El número de puntos para la tabla debe estar entre 2 y 100.</div>`;
                    } else {
                        analysisOutputHTML += `<p><b>Tabla de Valores (${n} puntos):</b></p>`;
                        analysisOutputHTML += `<pre>x        f(x)\n--------------------\n`;
                        const step = (endX - startX) / (n - 1);
                        for (let i = 0; i < n; i++) {
                            const xVal = startX + i * step;
                            const yVal = f(xVal);
                            analysisOutputHTML += `${xVal.toFixed(3).padEnd(8)} ${isFinite(yVal) ? yVal.toFixed(4) : "Indefinido"}\n`;
                        }
                        analysisOutputHTML += `</pre>`;
                    }
                }

                if (order.includes("monotonía")) {
                    let isGrowing = true;
                    let isDecreasing = true;
                    let lastValidY = NaN;
                    const tolerance = 1e-3; // Pequeña tolerancia para la comparación

                    for (let i = 0; i < ys.length; i++) {
                        if (!isNaN(ys[i]) && isFinite(ys[i])) {
                            if (!isNaN(lastValidY) && isFinite(lastValidY)) {
                                if (ys[i] < lastValidY - tolerance) isGrowing = false;
                                if (ys[i] > lastValidY + tolerance) isDecreasing = false;
                            }
                            lastValidY = ys[i];
                        }
                    }
                    if (isGrowing && !isDecreasing) {
                        analysisOutputHTML += `<p><b>Monotonía aproximada:</b> La función es mayormente **creciente** en el intervalo.</p>`;
                    } else if (isDecreasing && !isGrowing) {
                        analysisOutputHTML += `<p><b>Monotonía aproximada:</b> La función es mayormente **decreciente** en el intervalo.</p>`;
                    } else if (isGrowing && isDecreasing) { // Si es constante
                        analysisOutputHTML += `<p><b>Monotonía aproximada:</b> La función parece ser **constante** en el intervalo.</p>`;
                    }
                     else {
                        analysisOutputHTML += `<p><b>Monotonía aproximada:</b> La función no es estrictamente creciente ni decreciente (puede tener subidas y bajadas) en el intervalo.</p>`;
                    }
                    analysisOutputHTML += `<div class="explanation">Una función es **creciente** si sus valores de $y$ aumentan a medida que $x$ aumenta. Es **decreciente** si sus valores de $y$ disminuyen.</div>`;
                }

                if (order.includes("simetría")) {
                    let isEven = true; // Simetría par: f(x) = f(-x)
                    let isOdd = true;  // Simetría impar: f(x) = -f(-x)
                    const symmetryTol = 0.1; // Tolerancia para la simetría

                    // Solo analizamos simetría si el intervalo es aproximadamente simétrico alrededor de 0
                    if (Math.abs(startX + endX) < Math.abs(endX - startX) * 0.1) {
                        const midPoint = (endX + startX) / 2;
                        for (let i = 0; i < numPoints / 2; i++) {
                            const x1 = xs[i];
                            const y1 = ys[i];
                            
                            // Encontrar el punto simétrico
                            const x2 = midPoint * 2 - x1; 
                            
                            // Evaluar f(x2)
                            let y2 = f(x2);

                            if (isNaN(y1) || isNaN(y2) || !isFinite(y1) || !isFinite(y2)) continue;

                            // Comprobar simetría par: f(x) == f(-x)
                            if (Math.abs(y1 - y2) > symmetryTol) {
                                isEven = false;
                            }
                            // Comprobar simetría impar: f(x) == -f(-x)
                            if (Math.abs(y1 - (-y2)) > symmetryTol) {
                                isOdd = false;
                            }
                            if (!isEven && !isOdd) break;
                        }
                    } else {
                        isEven = false; // No se puede determinar si el intervalo no es simétrico
                        isOdd = false;
                    }


                    if (isEven) {
                        analysisOutputHTML += `<p><b>Simetría aproximada:</b> La función parece ser **par** (simétrica con respecto al eje Y).</p>`;
                        analysisOutputHTML += `<div class="explanation">Una función es **par** si $f(x) = f(-x)$. Su gráfica es simétrica con respecto al eje Y.</div>`;
                    } else if (isOdd) {
                        analysisOutputHTML += `<p><b>Simetría aproximada:</b> La función parece ser **impar** (simétrica con respecto al origen).</p>`;
                        analysisOutputHTML += `<div class="explanation">Una función es **impar** si $f(x) = -f(-x)$. Su gráfica es simétrica con respecto al origen (0,0).</div>`;
                    } else {
                        analysisOutputHTML += `<p><b>Simetría aproximada:</b> La función no parece ser par ni impar en el intervalo. (Requiere un intervalo centrado en 0 para un análisis preciso).</p>`;
                        analysisOutputHTML += `<div class="explanation">La simetría par significa $f(x) = f(-x)$ (eje Y). La simetría impar significa $f(x) = -f(-x)$ (origen).</div>`;
                    }
                }
                
                analysisText.innerHTML = analysisOutputHTML;
            }

            // Manejador de evento para el botón
            analyzeButton.addEventListener('click', analyzeAndPlot);

            // Inicializar con la gráfica de x^2 al cargar la página
            analyzeAndPlot();

            // Manejo del redimensionamiento del contenedor para la gráfica
            let resizeTimeout;
            const resizeObserver = new ResizeObserver(entries => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    for (let entry of entries) {
                        const currentWidth = entry.contentRect.width;
                        const previousWidth = graphContainer.dataset.lastWidth ? parseFloat(graphContainer.dataset.lastWidth) : 0;

                        if (Math.abs(currentWidth - previousWidth) > 5) { // Un umbral de 5px para evitar redibujos menores
                            analyzeAndPlot(); // Re-ejecutar el análisis para redibujar la gráfica
                            graphContainer.dataset.lastWidth = currentWidth; // Guardar el nuevo ancho
                        }
                    }
                }, 250); // Pequeño retraso para evitar redibujos excesivos
            });

            resizeObserver.observe(graphContainer);
        });
    </script>

</body>
</html>
